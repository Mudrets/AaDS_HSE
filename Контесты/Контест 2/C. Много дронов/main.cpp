#include "ReadWriter.h"
#include <iostream>

/* Это код, который я отправил во второй посылке, как
 * оказалось он полностью рабочий и решает данную
 * задачу за нужное время, но по какой-то причине
 * на 12 тесте он не проходил по времени, как
 * и мои следующие 22 попытки, я испробовал несколько
 * разных алгоритмов, пытался оптимизировать код,
 * хотел выиграть время за счет памяти так как ее
 * мне более чем достаточно, убрал все, что хоть
 * как-то может занимать время, но результат так и не
 * менялся... Каждый раз я видел TL 1.092s и не понимал
 * что просходит. Иногда контест радовал меня такими
 * значениями времени как 1.016s и 1.03s и тогда мне
 * казалось, что я на верном пути, оказалось это были
 * просто жестокие издевательства контеста надо мной
 * ведь когда я отправлял тот же самый код, работающий
 * за 1.016s и 1.03s, второй раз, то опять получал
 * это прекрасное значение 1.092s... 92 - цифра боли
 * и страданий, пытка, которую в древнем Китае использовали
 * для наказания старшнейших убийц того времени...
 * Сегодня я опробовал ее на себе и могу сказать, что
 * это бесчеловечная процедура, через которую я бы
 * не пожелал пройти даже своему самому заклятому врагу.
 * Вы спросите меня "А за что все эти жуткие пытки, чем
 * же ты так провинился, что с тобой так жестоко поступили?"
 * Я совершил страшное преступление, все те 28 попыток я не
 * использовал шаблон. По глупости я решил, что могу
 * обойтись без какого-то там шаблона, ведь с ним мне
 * будет не удобно решать задачу так, как я хочу.
 * "Что я, не смогу написать чтение и запись в файл в мейне
 * сам?" подумал я... Это была страшнейшая мысль за всю мою
 * жизнь, забравшая у меня 6 часов времени.
 *
 * Ниже можно посмотреть решение задачи через сортировку
 * подсчетом, она тоже зашла на ОК, но мне кажется, что
 * этот алгоритм интереснее. */

struct Drone {
    int id;
    int liftingCapacity;
};

//Слияние отсортированных в порядке невозрастания массивов с
//сортировкой полученного массива в порядке не возрастания
void merge(Drone* arr, int firstInd, int lastInd) {
    int bufSize = lastInd - firstInd + 1; //Находим размер буфера
    auto* buf = new Drone[bufSize];
    for (int i = 0; i < bufSize; ++i) //Заполняем буфер
        buf[i] = arr[firstInd + i];

    int mid = (lastInd - firstInd) / 2; //Находим разницу деленую на 2
    int j = 0, k = mid + 1; //Определяем индексы начала двух частей
    //Объединяем массивы
    for (int i = firstInd; i <= lastInd; ++i) {
        if (j > mid)
            arr[i] = buf[k++];
        else if (k > lastInd - firstInd)
            arr[i] = buf[j++];
        else if (buf[j].liftingCapacity < buf[k].liftingCapacity)
            arr[i] = buf[k++];
        else
            arr[i] = buf[j++];
    }
    delete[] buf;
}

//Сортировка слиянием
//Свойства:
// - Устойчивая
// - Худшее время: O(n*logn)
// - Среднее время: O(n*logn)
// - Лучшее время: O(n*logn)
// - Затраты памяти: O(n)
void mergeSort(Drone* arr, int firstInd, int lastInd) {
    if (firstInd >= lastInd) //Если разбить невозможно (Элемент один)
        return;
    int mid = firstInd + (lastInd - firstInd) / 2;
    //Сортируем 2 части массива отдельно
    mergeSort(arr, firstInd, mid); //Сортировка первой части
    mergeSort(arr, mid + 1, lastInd); //Сортировка второй части
    merge(arr, firstInd, lastInd); //Слияние двух частей в одну
}

int main() {
    //Объект для работы с файлами
    ReadWriter rw;

    int *arrId = nullptr;
    int *arrWeight = nullptr;

    int n;

    //Ввод из файла
    n = rw.readInt();

    arrId = new int[n];
    arrWeight = new int[n];
    rw.readArrays(arrId, arrWeight, n);

    auto* drones = new Drone[n];
    for (int i = 0; i < n; ++i) {
        drones[i].id = arrId[i];
        drones[i].liftingCapacity = arrWeight[i];
    }

    //Запуск сортировки, ответ в том же массиве (brr)
    mergeSort(drones, 0, n);

    for (int i = 0; i < n; ++i) {
        arrId[i] = drones[i].id;
        arrWeight[i] = drones[i].liftingCapacity;
    }

    //Запись в файл
    rw.writeArrays(arrId, arrWeight, n);

    //освобождаем память
    delete[] arrId;
    delete[] arrWeight;

    return 0;
}